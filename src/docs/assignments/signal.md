---
title: Signal
name: signal
due: January 1 
---

Theme Song: [Payphone](https://www.youtube.com/watch?v=KRaWnd3LJfs&ab_channel=Maroon5VEVO)

In this assignment, you'll explore ways that we can compose the cryptographic primitives we've been exploring to build a secure communication framework. In particular, we build a system wherein eavesdroppers cannot decipher or modify messages without our knowledge. However, our system will still be vulnerable to man-in-the-middle attacks.

---

# Background Knowledge

In this assignment, you will build a secure communication platform. On startup, each client specifies whether it will wait for a connect or connect to another client; once two clients have connected, they will run **Diffie-Hellman** key exchange to reach a shared secret. Once we have a shared secret, both parties run **HKDF key derivation** on it to derive a secure key for the **AES block cipher**, which they then use to encrypt and decrypt messages in tandem. To ensure that messages aren't tampered with, each message is also tagged with a **HMAC authentication code**. We go over each of these components in detail below.

## Key Exchange

We've already explored **key exchange** in the previous assignment, but it's worth revisiting. Often, when two parties wish to communicate securely, it is useful to have some shared secret key that they can use to encrypt and decrypt their messages. Indeed, the block cipher that we use in this assignment requires such a secret. Diffie-Hellman key exchange is one method for coming to a shared secret.

Diffie-Hellman works in three steps. First, system parameters are generated and shared amongst the parties; these parameters include a prime $$p$$, a generator $$g$$, and the order of the subgroup generated by $$g$$, $$q$$.  Once these parameters are generated, each party generates a secret and public value, sharing the public value. Finally, the secret and public values are combined to create a shared secret.

## Block Ciphers

Often, we wish to encrypt lots of data at a time without having to come to new secrets every time, without comprimising the security of our existing key. A **block cipher** is an encryption scheme that works on fixed-length **blocks** at a time. They are very useful for encryption large or arbitrary-length data, such as messages or videos. **AES (Advanced Encryption Standard)** is one such block cipher; it was adopted by NIST in 2001 after winning a 5-year public competition to become the new standard secure cipher. To use AES, simply provide it with a message and a suitable key; it will then output the ciphertext (the API for AES is quite simple despite its complexity). The inner workings of AES are extremely complicated and out of scope for this class.

The key we generate through Diffie-Hellman may not be sufficient for AES. For example, it may not be long enough, it may be the wrong size, or may have a distribution that doesn't preserve the security guarantees of AES. To this end, we use a **secure key derivation function** to convert a shared secret into an acceptable key. In this assignment we use **HKDF**, a widely used key derivation function, to generate keys for AES.

## Message Integrity

An important aspect of communication is message integrity; we want to be sure that our messages haven't been tampered with in transit. A **MAC (Message Authentication Code)** is one such way of cryptographically ensuring message integrity. A MAC generator takes in a secret and a message and outputs a tag. A MAC verifier takes in a secret, a MAC tag, and the message it corresponds to and outputs "Verified" (or some other positive value) if and only if the MAC is valid for the given message. The MAC that is computed on some value can be thought of as a signature (although as we'll see later, these are subtly different constructs). In this assignment we use **HMAC**, a widely used MAC function, to tag our messages.

We need to be careful about the order in which we apply our cryptographic primitives. In particular; should we compute MACs on plaintext then encrypt the plaintext, or should we encrypt our plaintext first, and apply our MAC on the resulting ciphertext? It turns out that only one of these is secure; we leave it as an exercise to find out why.

## Putting it all together

The following diagram explains how the protocol works together.

![/static/img/handout/signal/architecture.png](Architecture)

---

# Assignment Specification

Please note: you may NOT change any of the function headers defined in the stencil. Doing so will break the autograder; if you don't understand a function header, please ask us what it means and we'll be happy to clarify.

## Functionality

You will primarily need to edit `crypto_driver.cxx` and `client.cxx`. The following is an overview of relevant files:
- `main.cxx` is the primary entrypoint to the program, running the Client defined in `client`. 
- `cli.cxx` implements a CLI that prints messages out to the screen.
- `network_driver.cxx` contains a class that sends and receives streams of bytes using TCP. 
- `structures.hpp` contains structs for each type of message you should expect to send and receive and `structures.cxx` contains the serialize and deserialize functions for these structs.
- `crypto_driver.cxx` contains all of the cryptographic protocols we use in this assignment.
- `client.cxx` glues together the crypto and networking functions into a cohesive application.

The following roadmap should help you organize concerns into a sequence:
- Establish shared secrets using Diffie-Hellman key exchange.
- Derive keys for use in AES block cipher using HKDF key derivation function.
- Encrypt messages using AES block cipher.
- Protect message integrity using HMAC authentication code.

In particular, you should implement the following functions:
- TODO: Function list.

Some tips:
- Diffie-Hellman key exchange takes a few messages; first, the parties need to agree on system parameters, then they need to exchange public values. It doesn't matter whether the server or the client generates and sends the Diffie-Hellman system parameters; however, to interoperate with our code, the connecting client (the client that called `connect`) should generate and send the parameters.
- You'll notice that the `message` struct has a Diffie-Hellman public value in it. You should detect when this value has changed from the last time you received a message; this allows clients to change their keys when they feel that a key has been compromised. This will cause issues with out-of-order messages, which you are not expected to handle.
- TODO: Explain SecByteBlock
- TODO: Others? 

## Libraries: CryptoPP

In this and future assignments, we will be using CryptoPP as our library of choice for our basic cryptographic primitives. CryptoPP is a widely used and trusted suite of cryptographic primitives; others like it include OpenSSL. We will introduce other libraries as the course goes along and make sure that you have all of the documentation you need on hand to build what we ask you to build.

You may find the following wiki pages useful during this assignment:
- [CryptoPP Diffie-Hellman](https://www.cryptopp.com/wiki/Diffie-Hellman)
- [CryptoPP HKDF](https://www.cryptopp.com/wiki/HKDF)
- [CryptoPP AES](https://www.cryptopp.com/wiki/Advanced_Encryption_Standard)
- [CryptoPP HMAC](https://www.cryptopp.com/wiki/HMAC)

## Written Response

Please respond to the following questions in your `README`.
- Should we MAC-then-Encrypt or Encrypt-then-MAC? Why?
- Describe a man-in-the-middle attack that compromises the security of our application. How should we solve it?

---

# Getting Started

To get started, get your stencil repository [here]() and clone it into the `devenv/home` folder. From here you can access the code from both your computer and from the Docker container.

## Running

To build the project, `cd`  into the `build` folder and run `cmake ..`. This will generate a set of Makefiles building the whole project. From here, you can run `make` to generate a binary you can run, `./signal_app`, and `make check` to run any tests you write in the `test` folder.

If you would like to add new files (e.g. to hold helper functions), make sure to include them in the `CMakeLists.txt` file s othat `cmake` can pick up on the new files.

## Testing

You may write tests in any of the `test/**.cpp` files in the Doctest format. If you want to add any new tests, make sure to add the file in line 4 of `test/CMakeLists.txt` so that `cmake` can pick up on the new files. Examples have been included in the assignment stencil. To run the tests run `make test` in the `build` directory.

---

# FAQ

- None yet!

---