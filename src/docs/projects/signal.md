---
title: Signal
name: signal
due: January 1 
---

Theme Song: [Payphone](https://www.youtube.com/watch?v=KRaWnd3LJfs&ab_channel=Maroon5VEVO)

In this assignment, you'll compose the cryptographic primitives we've been exploring to build a secure communication framework. In particular, we build a system wherein eavesdroppers cannot decipher or modify messages without our knowledge. You'll become much more familiar with cryptographic libraries and be prepared to take up larger protocols later in the course.

---

# Background Knowledge

In this assignment, you will build a secure communication platform. On startup, each client specifies whether it will *listen* or *connect* to another client; once two clients have connected, they will run a **key exchange protocol** to reach a shared secret. Once we have a shared secret, both parties run a **key derivation function** on it to derive a secure key for the **block cipher**, which they can then use to encrypt and decrypt messages in tandem. To ensure that messages aren't tampered with, each message is also tagged with a **message authentication code**, which is generated from another secure key. We go over each of these components in detail below.

## Key Exchange

We've already explored **key exchange** in the previous assignment, but it's worth revisiting. Often, when two parties wish to communicate securely, it is useful to have some shared secret key that they can use to encrypt and decrypt their messages. Indeed, the block cipher that we use in this assignment requires such a secret. **Diffie-Hellman key exchange** is one method for coming to a shared secret.

Diffie-Hellman works in three steps. First, system parameters are generated and shared amongst the parties. These parameters include a group $G$ (often $\mathcal{Z}_p$, a generator $g$, and the order of the subgroup generated by $g$, denoted $q$.  Once these parameters are shared, each party generates both a secret ($a, b$) and public ($g^a, g^b$) value and shares the public value. Finally, the secret and public values are combined to create a shared secret ($g^{ab}$).

## Block Ciphers

Often, we wish to encrypt lots of data without having to generate new secret keys every time nor comprimising the security of our existing key. A **block cipher** is an encryption scheme that works on fixed-length **blocks** at a time. They are very useful for encryption large or arbitrary-length data, such as messages or videos. **AES (Advanced Encryption Standard)** is one such block cipher; it was adopted by NIST in 2001 after winning a 5-year public competition to become the new standard secure cipher. To use AES, simply provide it with a message and a suitable key; it will then output the ciphertext (the API for AES is quite simple despite its complexity). The inner workings of AES are extremely complicated and out of scope for this class.

## Message Integrity

An important aspect of communication is message integrity; we want to be sure that our messages haven't been tampered with in transit. A **MAC (Message Authentication Code)** is one such way of cryptographically ensuring message integrity. A MAC generator takes in a shared secret and a message and outputs a tag for the message. A MAC verifier takes in the shared secret, a message, a MAC tag, and outputs "Verified" (or some other positive value) if and only if the MAC is valid for the given message; otherwise, it rejects the tag, indicating that the value has been tampered with or that the MAC was generated incorrectly. It must be difficult for those without the shared secret to generate valid MACs for any message, otherwise, this wouldn't be secure. The MAC that is computed on some value can be thought of as a signature (although as we'll see later, these are subtly different constructs). In this assignment we use **HMAC**, a widely used MAC function, to tag our messages.

We need to be careful about the order in which we apply our cryptographic primitives. In particular; should we compute MACs on plaintext then encrypt the plaintext, or should we encrypt our plaintext first, and apply our MAC on the resulting ciphertext? It turns out that only one of these is secure; we leave it as an exercise to explore why.

## Key Derivation

The key we generate through Diffie-Hellman and the PRG may not be sufficient for AES or HMAC.  For example, it may not be long enough, it may be the wrong size, or may have a distribution that doesn't preserve the security guarantees of AES. Moreover, we want to use different keys for AES and HMAC to preserve security. To this end, we use a **secure key derivation function** to convert a shared secret into an acceptable key. In this assignment we use **HKDF**, a widely used key derivation function, to generate secure keys. To ensure that HKDF generates different keys for AES and HMAC, we **salt** the Diffie-Hellman shared secret in the HKDF calls; salts have been provided for you already in the stencil code, and should be passed into the HKDF call as a parameter.

## Putting it all together

The following diagram explains how the protocol works together.

![Architecture](/static/img/handout/signal/architecture.png)

In short, we proceed in two steps; key exchange and then communication.

### Key Exchange

When our client starts up, we'll first connect to the other client we're interested in communicating with, then we'll set up to exchange keys. One of the clients (the one that called "connect") will generate and send the Diffie-Hellman parameters ($p, g, q$) to the other (`DH_generate_params`), which will listen for them. Once the parameters are received, both clients will generate their secret and public values (`DH_generate_shared_key`) and send the public value to the other client. Lastly, each client will combine the value they received with their secret value to reach a shared secret.

### Communication

Using the Diffie-Hellman shared secret, each client derives a key for each of AES (`AES_generate_shared_key`) and HMAC (`HMAC_generate_shared_key`) using HKDF. Each time a client wishes to send a message, they first encrypt it using AES (`AES_encrypt`) and tag the message with an HMAC (`HMAC_generate`).  Each time a client receives a message, they verify that the HMAC is valid (`HMAC_verify`) and decrypt it using AES (`AES_decrypt`).

---

# Assignment Specification

Please note: you may NOT change any of the function headers defined in the stencil. Doing so will break the autograder; if you don't understand a function header, please ask us what it means and we'll be happy to clarify.

## Functionality

You will primarily need to edit `src/drivers/crypto_driver.cxx` and `src/pkg/client.cxx`. The following is an overview of relevant files:
- `src/cmd/main.cxx` is the primary entrypoint to the program, running the Client defined in `client`. 
- `src/drivers/crypto_driver.cxx` contains all of the cryptographic protocols we use in this assignment.
- `src/pkg/client.cxx` glues together the crypto and networking functions into a cohesive application.

The following roadmap should help you organize concerns into a sequence:
- Establish shared secrets using Diffie-Hellman key exchange.
- Derive keys for use in AES using HKDF key derivation function.
- Encrypt messages using AES.
- Derive keys for use in HMAC using HKDF key derivation function.
- Protect message integrity using HMAC.

In particular, you should implement the following functions:
- `Message_Message Client::encrypt(std::string plaintext)`
- `std::pair<std::string, bool> Client::decrypt(MessageStruct ciphertext)`
- `void Client::run(std::string command)`
- `void Client::receive_thread()`
- `void Client::send_thread()`
- `DHParams_Message CryptoDriver::DH_generate_params()`
- `std::pair<SecByteBlock, SecByteBlock> CryptoDriver::DH_initialize(DHParams_Message params)`
- `void CryptoDriver::DH_generate_shared_key(CryptoPP::SecByteBlock otherKey)`
- `void CryptoDriver::AES_generate_shared_key()`
- `std::string CryptoDriver::AES_encrypt(std::string plaintext)`
- `std::string CryptoDriver::AES_decrypt(std::string ciphertext)`
- `void CryptoDriver::HMAC_generate_shared_key()`
- `std::string CryptoDriver::HMAC_generate(std::string ciphertext)`
- `bool CryptoDriver::HMAC_verify(std::string ciphertext, std::string hmac)`

Some tips:
- Most of the code you'll be writing in this assignment will be similar to that in the links provided in the Library section below. We highly recommend perusing those wikis before starting. In particular, the Pipelining wiki page is useful for understanding how the CryptoPP library works.
- We recommend reading through our support code header files before coding so you have a sense of what functionality we provide. This isn't a networking class, nor is it a software engineering class, so we try to abstract away as many of these details as we can so you can focus on the cryptography.
- A `SecByteBlock` is a variable where we can securely store keys in memory; many library functions that you will be calling require this type. When initializing `SecByteBlock`s, you should pass in the length of the value it will be holding; for example, `dh.PrivateKeyLength()` or `dh.AgreedValueLength()` or `SHA256::DIGESTSIZE`. We've included helper functions for you to print out the contents of a `SecByteBlock`.
- When generating a group, we should have a `delta` of 1, a `pbits` of 512, and a `qbits` of 511: `pg.Generate(1, prng, 512, 511);`

## Support Code

The following is an overview of the functionality that each support code file provides.
- `src/drivers/network_driver.cxx` provides a convenient wrapper around low level network calls for you to use. We send and receive data as `std::vector<unsigned char>` and have provided helper function to convert between this type and `std::string`. Use the `send` and `read` functions to send and receive data safely.
- `src/drivers/cli_driver.cxx` provides a CLI. You should use the provided `CLIDriver` to print values out to the left (`print_left`) and right (`print_right`) of the screen. 
- `src-shared/logger.cxx` provides logging utility functions that may be useful for debugging.
- `src-shared/messages.cxx` provides the message types that we can send and receive over the wire, including functions to serialize and deserialize these types from `std::vector<unsigned char>`.  See the associated header file for the struct definitions.
- `src-shared/serialize.hpp` contains serialization and debug methods for many of the types you'll be using.
- `src-shared/util.hpp` contains useful debugging and converting primitives. Check back here first if you're not sure how to convert types; chances are we've already taken care if it.

## Messaging

The following example shows how to use our message library alongside our networking library; we'll be using this pattern for the entire course, so it's good to get it down now.

```
// Declare the message struct that we want to send and populate its fields
PublicValue_Message msg_s;
msg_s.value = "foobar";

// Declare a data vector and serialize the message into the data vector
std::vector<unsigned char> msg_data;
msg_s.serialize(msg_data);

// Send the data
this->network_driver->send(msg_data);

// ----

// Read the data
std::vector<unsigned char> their_msg_data = this->network_driver->read();

// Declare a message struct and deserialize the data into the struct.
PublicValue_Message their_msg_s;
their_msg_s.deserialize(their_msg_data);
```

## Libraries: CryptoPP

You may find the following wiki pages useful during this assignment:
- [CryptoPP Diffie-Hellman](https://www.cryptopp.com/wiki/Diffie-Hellman)
- [CryptoPP HKDF](https://www.cryptopp.com/wiki/HKDF)
- [CryptoPP AES](https://www.cryptopp.com/wiki/Advanced_Encryption_Standard)
- [CryptoPP HMAC](https://www.cryptopp.com/wiki/HMAC)
- [CryptoPP Pipelining](https://www.cryptopp.com/wiki/Pipelining)

---

# Getting Started

To get started, get your stencil repository [here](https://classroom.github.com/a/49699wIe) and clone it into the `devenv/home` folder. From here you can access the code from both your computer and from the Docker container.

## Running

To build the project, `cd`  into the `build` folder and run `cmake ..`. This will generate a set of Makefiles building the whole project. From here, you can run `make` to generate a binary you can run, and you can run `make check` to run any tests you write in the `test` folder.

To run the binary, run `./signal_app <listen|connect> [address] [port]` on two terminals with different ports, one using `listen` and the other `connect` (listen before connect). This should run the app and allow you to communicate.

## Testing

You may write tests in any of the `test/**.cpp` files in the Doctest format. If you want to add any new tests, make sure to add the file in line 4 of `test/CMakeLists.txt` so that `cmake` can pick up on the new files. Examples have been included in the assignment stencil. To run the tests run `make test` in the `build` directory.

---

# FAQ

- None yet!

---
