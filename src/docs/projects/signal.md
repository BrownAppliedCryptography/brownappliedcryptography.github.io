---
title: Signal
name: signal
due: January 1 
---

Theme Song: [Payphone](https://www.youtube.com/watch?v=KRaWnd3LJfs&ab_channel=Maroon5VEVO)

In this assignment, you'll compose the cryptographic primitives we've been exploring to build a secure communication framework. In particular, we build a system wherein eavesdroppers cannot decipher or modify messages without our knowledge. However, our system will still be vulnerable to man-in-the-middle attacks.

---

# Background Knowledge

In this assignment, you will build a secure communication platform. On startup, each client specifies whether it will *listen* or *connect* to another client; once two clients have connected, they will run a **key exchange protocol** to reach a shared secret. Once we have a shared secret, both parties run a **key derivation function** on it to derive a secure key for the **block cipher**, which they can then use to encrypt and decrypt messages in tandem. To ensure that messages aren't tampered with, each message is also tagged with a **message authentication code**. We go over each of these components in detail below.

## Key Exchange

We've already explored **key exchange** in the previous assignment, but it's worth revisiting. Often, when two parties wish to communicate securely, it is useful to have some shared secret key that they can use to encrypt and decrypt their messages. Indeed, the block cipher that we use in this assignment requires such a secret. **Diffie-Hellman key exchange** is one method for coming to a shared secret.

Diffie-Hellman works in three steps. First, system parameters are generated and shared amongst the parties. These parameters include a prime $p$, a generator $g$, and the order of the subgroup generated by $g$, denoted $q$.  Once these parameters are generated, each party generates both a secret ($a, b$) and public ($g^a, g^b$) value and shares the public value. Finally, the secret and public values are combined to create a shared secret ($g^{ab}$).

While in the previous assignment we interacted with Diffie-Hellman using integers, in this assignment and beyond we will use **Elliptic Curve Diffie-Hellman**. Diffie-Hellman works with any* group, and using elliptic curves offers us better security guarantees that are outside the scope of this course to explore. You don't need to understand ECDH, you just need to use its library.

## Pseudorandom Generators

You'll notice that we run key exchange once, but we will end up needing two keys later on. To solve this problem, we use what's known as a **length-doubling pseudorandom generator**, or **PRG** for short. A pseudorandom generator allows us to deterministically get more random-seeming data from some random seed in a secure fashion. We'll use a PRG to extend our one secret from key exchange into two that we can use for both block ciphers and MACs.

## Block Ciphers

Often, we wish to encrypt lots of data without having to generate new secret keys every time nor comprimising the security of our existing key. A **block cipher** is an encryption scheme that works on fixed-length **blocks** at a time. They are very useful for encryption large or arbitrary-length data, such as messages or videos. **AES (Advanced Encryption Standard)** is one such block cipher; it was adopted by NIST in 2001 after winning a 5-year public competition to become the new standard secure cipher. To use AES, simply provide it with a message and a suitable key; it will then output the ciphertext (the API for AES is quite simple despite its complexity). The inner workings of AES are extremely complicated and out of scope for this class.

The key we generate through Diffie-Hellman and the PRG may not be sufficient for AES. For example, it may not be long enough, it may be the wrong size, or may have a distribution that doesn't preserve the security guarantees of AES. To this end, we use a **secure key derivation function** to convert a shared secret into an acceptable key. In this assignment we use **HKDF**, a widely used key derivation function, to generate keys for AES.

## Message Integrity

An important aspect of communication is message integrity; we want to be sure that our messages haven't been tampered with in transit. A **MAC (Message Authentication Code)** is one such way of cryptographically ensuring message integrity. A MAC generator takes in a shared secret and a message and outputs a tag for the message. A MAC verifier takes in the shared secret, a message, a MAC tag, and outputs "Verified" (or some other positive value) if and only if the MAC is valid for the given message; otherwise, it rejects the tag, indicating that the value has been tampered with. It must be difficult for those without the shared secret to generate valid MACs for any message, otherwise, this wouldn't be secure. The MAC that is computed on some value can be thought of as a signature (although as we'll see later, these are subtly different constructs). In this assignment we use **HMAC**, a widely used MAC function, to tag our messages. We'll use the other key generated from Diffie-Hellman and the PRG in conjunction with HKDF with HMAC.

We need to be careful about the order in which we apply our cryptographic primitives. In particular; should we compute MACs on plaintext then encrypt the plaintext, or should we encrypt our plaintext first, and apply our MAC on the resulting ciphertext? It turns out that only one of these is secure; we leave it as an exercise to find out why.

## Putting it all together

The following diagram explains how the protocol works together.

![Architecture](/static/img/handout/signal/architecture.png)

In short, we proceed in two steps; key exchange and then communication.

### Key Exchange

When our client starts up, we'll first connect to the other client we're interested in communicating with, then we'll set up to exchange keys. One of the clients (the one that called "connect") will generate and send the Diffie-Hellman parameters ($p, g, q$) to the other, which will listen for them. Once the parameters are received, both clients will generate their secret and public values and send the public value to the other client. Lastly, each client will combine the value they received with their secret value to reach a shared secret.

### Communication

Using the Diffie-Hellman shared secret, each client extends the secret into two, then derives a key for each of AES and HMAC using HKDF. Each time a client wishes to send a message, they first encrypt it using AES (`ECBencrypt`) and tag the message with an HMAC.  Each time a client receives a message, they verify that the HMAC is valid and decrypt it using AES (`ECBdecrypt`).

---

# Assignment Specification

Please note: you may NOT change any of the function headers defined in the stencil. Doing so will break the autograder; if you don't understand a function header, please ask us what it means and we'll be happy to clarify.

## Functionality

You will primarily need to edit `drivers/crypto_driver.cxx` and `pkg/client.cxx`. The following is an overview of relevant files:
- `cmd/main.cxx` is the primary entrypoint to the program, running the Client defined in `client`. 
- `drivers/cli_driver.cxx` implements a CLI that prints messages out to the screen.
- `drivers/crypto_driver.cxx` contains all of the cryptographic protocols we use in this assignment.
- `drivers/network_driver.cxx` contains a class that sends and receives streams of bytes using TCP. 
- `pkg/client.cxx` glues together the crypto and networking functions into a cohesive application.
- `pkg/messages.hpp` contains structs for each type of message you should expect to send and receive and `structures.cxx` contains the serialize and deserialize functions for these structs.

The following roadmap should help you organize concerns into a sequence:
- Establish shared secrets using Diffie-Hellman key exchange.
- Extend the shared secret using a PRG.
- Derive keys for use in AES block cipher using HKDF key derivation function.
- Encrypt messages using AES block cipher.
- Protect message integrity using HMAC authentication code.

In particular, you should implement the following functions:
- `Message encrypt(std::string plaintext)`
- `std::tuple<std::string, bool> decrypt(Message ciphertext)`
- `void Client::run(std::string command)`
- `void Client::listenForPublicKey()`
- `void Client::receiveThread()`
- `void Client::sendThread()`
- `DHParams CryptoDriver::generateParams()`
- `std::pair<SecByteBlock, SecByteBlock> CryptoDriver::initialize(DHParams params)`
- `void CryptoDriver::DH_generateSharedKey(CryptoPP::SecByteBlock otherKey)`
- `void CryptoDriver::AES_generateSharedKey()`
- `std::string CryptoDriver::AES_encrypt(std::string plaintext)`
- `std::string CryptoDriver::AES_decrypt(std::string ciphertext)`
- `std::string CryptoDriver::HMAC_generate(std::string ciphertext)`
- `bool CryptoDriver::HMAC_verify(std::string ciphertext, std::string mac)`

Some tips:
- Most of the code you'll be writing in this assignment will be similar to that in the links provided in the Library section below. We highly recommend perusing those wikis before starting.
- You'll notice that the `message` struct has a Diffie-Hellman public value in it. You should detect when this value has changed from the last time you received a message; this allows clients to change their keys when they feel that a key has been compromised. This will cause issues with out-of-order messages, which you are not expected to handle.
- A `SecByteBlock` is a variable where we can securely store keys in memory; many library functions that you will be calling require this type. When initializing `SecByteBlock`s, you should pass in the length of the value it will be holding; for example, `dh.PrivateKeyLength()` or `dh.AgreedValueLength()` or `SHA256::DIGESTSIZE`. We've included helper functions for you to print out the contents of a `SecByteBlock`.
- When sending things through the network, use the provided `chvec2str` and `str2chvec` to convert between `std::string` and `std::vector<unsigned char>`.
- We recommend reading through our support code header files before coding so you have a sense of what functionality we provide. This isn't a networking class, nor is it a software engineering class, so we try to abstract away as many of these details as we can so you can focus on the cryptography.

## Support Code

The following is an overview of the functionality that each support code file provides.
- `drivers/network_driver.cxx` - This file provides a convenient wrapper around low level network calls for you to use. We send and receive data as `std::vector<unsigned char>` and have provided helper function to convert between this type and `std::string`. Use the `send` and `read` functions to send and receive data safely.
- `drivers/cli_driver.cxx` - This file provides a CLI. You should use the provided `CLIDriver` to print values out to the left (`printLeft`) and right (`printRight`) of the screen. 
- `pkg/messages.cxx` - This file provides the message types that we can send and receive over the wire, including functions to serialize and deserialize these types from `std::vector<unsigned char>`.  See the associated header file for the struct definitions.
- `pkg/messages.cxx` - This file provides the message types that we can send and receive over the wire, including functions to serialize and deserialize these types from `std::vector<unsigned char>`.  See the associated header file for the struct definitions.

## Libraries: CryptoPP

In this and future assignments, we will be using CryptoPP as our library of choice for our basic cryptographic primitives. CryptoPP is a widely used and trusted suite of cryptographic primitives; others like it include OpenSSL. We will introduce other libraries as the course goes along and make sure that you have all of the documentation you need on hand to build what we ask you to build.

You may find the following wiki pages useful during this assignment:
- [CryptoPP Diffie-Hellman](https://www.cryptopp.com/wiki/Diffie-Hellman)
- [CryptoPP HKDF](https://www.cryptopp.com/wiki/HKDF)
- [CryptoPP AES](https://www.cryptopp.com/wiki/Advanced_Encryption_Standard)
- [CryptoPP HMAC](https://www.cryptopp.com/wiki/HMAC)

---

# Getting Started

To get started, get your stencil repository [here](https://classroom.github.com/a/49699wIe) and clone it into the `devenv/home` folder. From here you can access the code from both your computer and from the Docker container.

## Running

To build the project, `cd`  into the `build` folder and run `cmake ..`. This will generate a set of Makefiles building the whole project. From here, you can run `make` to generate a binary you can run, `./signal_app`, and `make check` to run any tests you write in the `test` folder.

If you would like to add new files (e.g. to hold helper functions), make sure to include them in the `CMakeLists.txt` file s othat `cmake` can pick up on the new files.

TODO: Usage details

## Testing

You may write tests in any of the `test/**.cpp` files in the Doctest format. If you want to add any new tests, make sure to add the file in line 4 of `test/CMakeLists.txt` so that `cmake` can pick up on the new files. Examples have been included in the assignment stencil. To run the tests run `make test` in the `build` directory.

---

# FAQ

- None yet!

---
